#!/usr/bin/env python

import sys
import os
import json
import argparse
import subprocess
import logging
import time
import socket
import requests
import yaml

from aeon.cros.device import Device
from aeon.exceptions import ProbeError, LoginNotReadyError, UnauthorizedError
from aeon.exceptions import ConfigError, CommandError

_PROGNAME = 'cros-bootstrap'
_PROGVER = '0.0.1'
_OS_NAME = 'cros'

_DEFAULTS = {
    'init-delay': 5,
    'reload-delay': 1*60,
    'user' : "ztp",
    'password' : "Ztp@1234"
}

# ##### -----------------------------------------------------------------------
# #####
# #####                           Command Line Arguments
# #####
# ##### -----------------------------------------------------------------------

psr = argparse.ArgumentParser(
    prog=_PROGNAME,
    description="Aeon-ZTP bootstrapper for Cumulus Linux",
    add_help=True)

psr.add_argument(
    '--target', required=True,
    help='hostname or ip_addr of target device')

psr.add_argument(
    '--server', required=True,
    help='Aeon-ZTP host:port')

psr.add_argument(
    '--topdir', required=True,
    help='Aeon-ZTP install directory')

psr.add_argument(
    '--logfile',
    help='name of log file')

psr.add_argument(
    '--reload-delay',
    dest='reload_delay',
    type=int, default=_DEFAULTS['reload-delay'],
    help="about of time/s to try to reconnect to device after reload")

psr.add_argument(
    '--init-delay',
    dest='init_delay',
    type=int, default=_DEFAULTS['init-delay'],
    help="amount of time/s to wait before starting the bootstrap process")

# ##### -------------------------
# ##### authentication
# ##### -------------------------

group = psr.add_argument_group('authentication')

group.add_argument(
    '--user', help='login user-name')

group.add_argument(
    '-U', dest='env_user',
    help='Username environment variable')

group.add_argument(
    '-P', dest='env_passwd',
    required=True,
    help='Passwd environment variable')

g_cli_args = psr.parse_args()
g_self_server = g_cli_args.server


def setup_logging(logname, logfile, target):
    log = logging.getLogger(name=logname)
    log.setLevel(logging.INFO)

    fmt = logging.Formatter(
        '%(asctime)s:%(levelname)s:{target}:%(message)s'
        .format(target=target))

    handler = logging.FileHandler(logfile) if logfile else logging.StreamHandler(sys.stdout)
    handler.setFormatter(fmt)
    log.addHandler(handler)

    return log


g_log = setup_logging(logname=_PROGNAME,
                      logfile=g_cli_args.logfile,
                      target=g_cli_args.target)


# ##### -----------------------------------------------------------------------
# #####
# #####                           REST API functions
# #####
# ##### -----------------------------------------------------------------------


def post_device_facts(dev):
    requests.put(
        url='http://%s/api/devices/facts' % g_self_server,
        json=dict(
            ip_addr=dev.target,
            serial_number=dev.facts['serial_number'],
            hw_model=dev.facts['hw_model'],
            os_version=dev.facts['os_version'],
            os_name=_OS_NAME))


def post_device_status(dev=None, target=None, message=None, state=None):
    requests.put(
        url='http://%s/api/devices/status' % g_self_server,
        json=dict(
            os_name=_OS_NAME,
            ip_addr=target or dev.target,
            state=state, message=message))


# ##### -----------------------------------------------------------------------
# #####
# #####                           Utility Functions
# #####
# ##### -----------------------------------------------------------------------

def exit_results(results, exit_error=None, dev=None, target=None):
    if results['ok']:
        post_device_status(dev=dev, target=target, state='DONE', message='bootstrap completed OK')
        sys.exit(0)
    else:
        post_device_status(dev=dev, target=target, state='FAILED', message=results['message'])
        sys.exit(exit_error or 1)


def wait_for_device(countdown, poll_delay):
    target = g_cli_args.target
    user = _DEFAULTS['user']
    passwd = _DEFAULTS['password']

    if not user:
        errmsg = "login user-name missing"
        g_log.error(errmsg)
        exit_results(target=target, results=dict(
            ok=False,
            error_type='login',
            message=errmsg))

    if not passwd:
        errmsg = "login user-password missing"
        g_log.error(errmsg)
        exit_results(target=target, results=dict(
            ok=False,
            error_type='login',
            message=errmsg))

    g_log.info("Opening device {}@{}".format(user, target));

    dev = None

    # first we need to wait for the device to be 'reachable' via the API.
    # we'll use the probe error to detect if it is or not

    while not dev:
        msg = 'reload-countdown at: {} seconds'.format(countdown)
        post_device_status(target=target, state='AWAIT-ONLINE', message=msg)
        g_log.info(msg)
        try:
            dev = Device(target, user=user, passwd=passwd,
                         timeout=poll_delay,
                         loghandle=g_log)

        except UnauthorizedError:
            exit_results(dev=dev, results=dict(
                ok=False,
                error_type='login',
                message='Unauthorized - check user/password'))

        except Exception:                # TODO: fix this broad exception
            countdown -= poll_delay
            if countdown <= 0:
                exit_results(dev=dev, results=dict(
                    ok=False,
                    error_type='login',
                    message='Failed to connect to target %s within reload countdown' % target))

            time.sleep(poll_delay)


    post_device_facts(dev)
    return dev


# ##### -----------------------------------------------------------------------
# #####
# #####                           General config process
# #####
# ##### -----------------------------------------------------------------------

def push_cfg_file(dev, cfg_f_path):
    url = cfg_f_path.replace(g_cli_args.topdir, g_self_server)
    f_name = os.path.basename(cfg_f_path)

    push_cmd = ["files download url {}".format(url)]
    config_cmd = ["config-file operation merge best-effort file {}".format(f_name)]

    post_device_status(
        dev=dev, state='CONFIG',
        message='applying config: %s' % f_name)

    try:
        dev.api.execute(push_cmd)
        dev.api.configure(config_cmd, comment = "Provisioned from {} via ZTP".format(url))
    except:
        raise

    g_log.info("Provisioned {}".format(url))



def do_push_config(dev):
    topdir = g_cli_args.topdir
    config_dir = os.path.join(topdir, 'etc', 'configs', 'cros')
    all_fpath = os.path.join(config_dir, 'all.cfg')
    model_fpath = os.path.join(config_dir, dev.facts['hw_model'] + '.cfg')
    
    device_dir = os.path.join(config_dir, dev.facts['serial_number'])
    device_startup_path = os.path.join(device_dir, "startup.cfg")

    try:
        os.makedirs(device_dir)
    except:
        pass

    # TODO: Add support for config file generation based on templates

    changed = False
    try:
        if os.path.isfile(device_startup_path):
            g_log.info('pushing device specific startup config file')
            push_cfg_file(dev, device_startup_path)
            changed = True
        else:
            g_log.info('no device startup config file found')
            
            if os.path.isfile(all_fpath):
                g_log.info('pushing all config to device')
                push_cfg_file(dev, all_fpath)
                changed = True
            else:
                g_log.info('no all.cfg file found')

            if os.path.isfile(model_fpath):
                g_log.info('pushing model config to device')
                push_cfg_file(dev, model_fpath)
                changed = True
            else:
                g_log.info('no model config file found: {}'.format(model_fpath))

    except Exception as exc:
        g_log.critical("unable to push config: {}".format(exc.message))
        exit_results(dict(
            ok=False,
            error_type='config',
            message=exc.message))

    if changed is True:
        dev.api.execute(["copy running-config startup-config"])



# ##### -----------------------------------------------------------------------
# #####
# #####                           OS install process
# #####
# ##### -----------------------------------------------------------------------

def get_required_os(dev):
    profile_dir = os.path.join(g_cli_args.topdir, 'etc', 'profiles', 'default', _OS_NAME)
    conf_fpath = os.path.join(profile_dir, 'os-selector.cfg')

    cmd = "{topdir}/bin/aztp-os-selector -m '{hw_model}' -o '{os_ver}' -c {config}".format(
        topdir=g_cli_args.topdir,
        hw_model=dev.facts['hw_model'],
        os_ver=dev.facts['os_version'],
        config=conf_fpath)

    g_log.info('os-select: [%s]' % cmd)

    child = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)

    _stdout, _stderr = child.communicate()
    g_log.info('os-select rc={}, stdout={}'.format(child.returncode, _stdout))
    g_log.info('os-select stderr={}'.format(_stderr))

    try:
        return json.loads(_stdout)

    except Exception:
        errmsg = 'Unable to load os-select output as JSON: {}'.format(_stdout)
        exit_results(dev=dev, results=dict(
            ok=False,
            error_type='install',
            message=errmsg))


def install_os(dev, image_name):
    vendor_dir = os.path.join(g_cli_args.topdir, 'vendor_images', _OS_NAME)

    image_fpath = os.path.join(vendor_dir, image_name)
    if not os.path.exists(image_fpath):
        errmsg = 'image file does not exist: %s' % image_fpath
        g_log.error(errmsg)
        exit_results(dev=dev, results=dict(
            ok=False, error_type='install',
            message=errmsg))

    msg = 'installing OS image=[%s] ... please be patient' % image_name
    g_log.info(msg)
    post_device_status(dev=dev, state='OS-INSTALL', message=msg)

    all_good, results = dev.api.execute([
        'sudo /usr/cros/bin/cl-img-install -sf http://{server}/images/{os_name}/{image_name}'
        .format(server=g_cli_args.server, os_name=_OS_NAME, image_name=image_name)
    ])

    if not all_good:
        import pdb
        pdb.set_trace()


def ensure_os_version(dev):
    os_install = get_required_os(dev)

    if not os_install['image']:
        g_log.info('no software install required')
        return dev

    g_log.info('software image install required: %s' % os_install['image'])
    install_os(dev, image_name=os_install['image'])

    g_log.info('software install OK')
    g_log.info('rebooting device ... please be patient')

    post_device_status(
        dev, state='OS-REBOOTING',
        message='OS install completed, now rebooting ... please be patient')

    dev.api.execute(['sudo reboot'])
    time.sleep(g_cli_args.init_delay)
    return wait_for_device(countdown=g_cli_args.reload_delay, poll_delay=10)


# ##### -----------------------------------------------------------------------
# #####
# #####                           !!! MAIN !!!
# #####
# ##### -----------------------------------------------------------------------

def main():
    if not os.path.isdir(g_cli_args.topdir):
        exit_results(dict(
            ok=False,
            error_type='args',
            message='{} is not a directory'.format(g_cli_args.topdir)))

    g_log.info("bootstrap init-delay: {} seconds"
               .format(g_cli_args.init_delay))

    post_device_status(
        target=g_cli_args.target,
        state='START',
        message='bootstrap started, waiting for device access')

    time.sleep(g_cli_args.init_delay)
    dev = wait_for_device(countdown=g_cli_args.reload_delay, poll_delay=10)

    g_log.info("proceeding with bootstrap")

    do_push_config(dev)
    ensure_os_version(dev)

    g_log.info("bootstrap process finished")
    exit_results(dict(ok=True), dev=dev)

if '__main__' == __name__:
    main()
